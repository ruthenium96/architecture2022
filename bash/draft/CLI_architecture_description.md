Архитектурное описание CLI.

Проектируемой CLI бдует соответствовать отдельный класс ShellExecutor, запускается при вызове метода execute. 
Конструктор принимает в качестве агрументов состояние оболочки State (переменные ENV, current_directory, aliases, history, etc) и глобальные потоки ввода-вывода.
Данная конструкция может быть использована в многопоточных программах путем использования атомарных классов состояния и потоков.

Внутри запускается Read-Execute-Print Loop до вызова команды exit.
В каждом таком цикле происходит считывание строки из потока и передача ее в парсер.
Заводится локальный класс потоков, который будет буферизовать ввод-вывод по мере выполнения программы, а в деструкторе будет печатать в целевые потоки.

Парсер работает как генератор, возвращая по методу get_next_cmd() следующую подкоманду (этим обеспечивает одинаковую обработку одиночной команды и пайпа).
Для сабкоманды выполняется метод Substitute с аргументом State, где происходит замена переменных $VAR на их значения в State->ENV->getVar(VAR).
Класс Subcommand содержит указатель на полиморфный класс Command: им может быть простая команда, команда требующая подстановки переменных из ENV, а также очередь команд (на случай расширения на сабшеллы).
После subcommand.preprocess(State) команда готова к исполнению.

Для исполнения мы создаем инстанс класса Program с аргументами subcommand, state, local_streams.
Данный класс связывает команду с исполняемым модулем (






