Архитектурное описание CLI.

Проектируемой CLI будет соответствовать отдельный класс ShellExecutor, запускается при вызове метода 'start'. 
Конструктор принимает в качестве аргументов состояние оболочки State (переменные `ENV`, `current_directory`, aliases, history, etc) и глобальные потоки ввода-вывода.
Данная конструкция может быть использована в многопоточных программах путем запуска нескольких инстансов и использования атомарных классов состояния и потоков.

Внутри запускается Read-Execute-Print Loop до вызова команды exit.
В каждом таком цикле происходит считывание строки из потока и передача ее в парсер (Агрегирует 1. Tokenizer и 2. Syntax_Checker).
Заводится локальный класс потоков, который будет буферизовать ввод-вывод по мере выполнения программы, а в деструкторе будет печатать в целевые потоки.

Далее цикл исполнения подкоманд (этим обеспечивается одинаковая обработка одиночной команды и пайпа).
Парсер работает как генератор, возвращая по методу `get_next_cmd()` следующую подкоманду (Subcommand). В идеале, парсер читает строку только раз.
Для подкоманды выполняется метод `Substitute` с аргументом `State`, где происходит замена переменных `$VAR` на их значения в `State->ENV->getVar(VAR)`, а также второй парсинг (Агрегирует возможно другие 1. Tokenizer и 2. Syntax_Checker).
В классе `Command` также хранятся массивы именованных и неименованных аргументов, которые после передаются в `Program`.
После `subcommand.preprocess(State)` команда готова к исполнению.

Для исполнения мы сопоставляем объекту класса Subcommand объект класса Program.
Запуск происходит при вызове `Program.apply()`, при этом имея доступ к переменным среды и буферизованным потокам.

При окончании цикла подкоманд, если генератор не пустой, буфер потока вывода перенаправляется в поток ввода, откуда следующая сабкоманда будет его брать.
В конце главного event loop выводим из буферизованного потока в целевой.

Модули `Program`, которые могут смотреть и изменять окружение `State`.
Это может быть либо реализованный модуль-класс (такими будут `wc`, `pwd`, `echo ...`).
Также это могут быть специальные внутренние модули `_set_var`, `_change_dir`, `_call_external_executable` (если команда не найдена).

Контроль исполнения и ошибок происходит с помощью выбрасывания исключений. Внутри цикла подкоманд проверяется правильность вторичного парсинга, а также результат исполнения команды.
В случае ошибки исполнение пайпа прекращается, а код ошибки помещается в соответствующую переменную ENV.
Для реализации exit выбрасывается исключение специального класса, при котором состояние ShellExecutor переводится в законченное, и внешний event loop останавливается.
(Так же возможно использование кодов возврата или обработки ошибок, основанном на алгебраических типах в духе функциональных ЯП).









