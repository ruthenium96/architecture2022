Архитектурное описание CLI.

Проектируемой CLI бдует соответствовать отдельный класс ShellExecutor, запускается при вызове метода execute. 
Конструктор принимает в качестве агрументов состояние оболочки State (переменные ENV, current_directory, aliases, history, etc) и глобальные потоки ввода-вывода.
Данная конструкция может быть использована в многопоточных программах путем запуска нескольких инстансов и использования атомарных классов состояния и потоков.

Внутри запускается Read-Execute-Print Loop до вызова команды exit.
В каждом таком цикле происходит считывание строки из потока и передача ее в парсер (Аггрегирует 1. Tokenizer и 2. Syntax_Checker).
Заводится локальный класс потоков, который будет буферизовать ввод-вывод по мере выполнения программы, а в деструкторе будет печатать в целевые потоки.

Далее цикл исполнения подкоманд (этим обеспечивается одинаковую обработка одиночной команды и пайпа).
Парсер работает как генератор, возвращая по методу get_next_cmd() следующую подкоманду.
Для сабкоманды выполняется метод Substitute с аргументом State, где происходит замена переменных $VAR на их значения в State->ENV->getVar(VAR), а также второй парсинг (Аггрегирует возможно другие 1. Tokenizer и 2. Syntax_Checker).
Класс Subcommand содержит указатель на полиморфный класс Command: им может быть простая команда, команда требующая подстановки переменных из ENV, а также очередь команд (на случай расширения на сабшеллы).
В классе 
После subcommand.preprocess(State) команда готова к исполнению.

Для исполнения мы создаем инстанс класса Program с аргументами subcommand, state, local_streams.
Данный класс связывает команду с исполняемым модулем (содержит указатель на класс Executable).
Запуск происходит при выхове Program.apply(), при этом Executable будет иметь доступ к переменным среды и буферизованным потокам.

При окончании цикла подкоманд, если генератор не пустой, буфер потока вывода перенаправляется в поток ввода, откуда следующая сабкоманда будет его брать.
В конце главного event loop выводим из буферизованного потока в целевой.

Рассмотрим работу Executable, которые могут смотреть и изменять окружение State.
Это может быть либо реализованный модуль-класс (такими будут wc, pwd, echo ...).
Также это могут быть специальные внутренние модули _set_var, _change_dir, _call_external_executable (если команда не найдена).










